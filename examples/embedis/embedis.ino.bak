#include <Arduino.h>
#include <kinetis.h> 

#include <EEPROM.h>
// The internal EEPROM (2K bytes on the Teensy 3.5/3.6) is used for non-volatile storage
// of "infrequently" changed information like calibration and configuration data,
// because it has a large, but finite and limited number (~170,000) of write cycles.
// Third party calibration data starts at low EEPROM address (0x0000) and grows upward (0x07FF).
//===============================================================================================
// on 03-11-2017 01:48 PM - PaulStoffregen said:
// "On Teensy 3.x, the hardware automatically wear levels. It actually uses flash memory and RAM to emulate EEPROM 
// (and Teensy LC uses a similar lower performance software-based approach without the dedicated RAM)
// To get higher endurance on Teensy 3.x you can edit hardware/teensy/avr/cores/teensy3/avr/eeprom.h reduce the size of E2END. 
// Smaller size will increase the wear leveling, but of course you get less writable EEPROM data.
// This only applies on Teensy 3.x. The software algorithm used on Teensy LC wear levels actual 
// usage across a fixed space, so there's nothing to tune on Teensy LC. 
// Reducing the E2END doesn't give you different endurance on LC, but it does on Teensy 3.2, 3.5 and 3.6."
// (okay, that makes me feel a little better about the EEPROM longevity...)
//===============================================================================================

#include <Embedis.h>
#define embedis_console Serial
Embedis embedis(embedis_console);

#include "Haptic_DA7280.h"

Haptic_DA7280 haptic;          // Basic I2C instance - only SDA/SCL pins used
int           effect = 0;      // current "effect" - a complex set of sequences or actions
int           effect_max = 0;  // max (loaded) effects available

void setup() {
  Serial.begin(115200);
   while (!Serial) {
    ; // wait for serial port to connect. Needed for native USB
  }
    // Start Logging
    LOG( String() + F("[ Haptic: Embedis Framework Installed ]") );

    // start all the subsystems and log it
    EEPROM_setup();
    LOG( String() + F("[ Haptic: Embedis EEPROM dictionary installed ]") );

  // initialize the Haptic controller
  if (haptic.begin() < 0) {
    LOG( String() + F("[ Haptic: Driver Error: Device not found - check your I2C connections? ]") );
  } else {
    int haptic_DeviceID = haptic.getDeviceID();
    if (haptic_DeviceID != HAPTIC_DEVICELIB) {
      Serial.println("Haptic: Driver Error: Device not recognized?");
      Serial.print("Haptic: DeviceID =  ");
      Serial.print(haptic_DeviceID, HEX);
      Serial.println(" was found? ");
    } else {
      Serial.print("Haptic: DeviceID =  ");
      Serial.print(haptic_DeviceID, HEX);
      Serial.println(" was found! ");
      haptic.setMode(REGISTER_MODE);    // trigger haptic effects by I2C register write i.e. "haptic.go()"
      effect_max = haptic.getEffects(); // set max to total number of effects loaded
      if (effect_max == 0) {
        Serial.println("Haptic: Driver Error: No Effects are available?");
      }
    }
  }       
}

void loop() {
  Serial.print("Effect #"); 
  Serial.println(effect);
  
  haptic.setEffect(effect);               // select an "effect" pattern
  haptic.go();                            // play the effect by register write
  delay(500);                             // wait for a while
  effect++;                                // next effect
  if (effect >= effect_max) effect = 0;  // loop through all the effects
}

// This will log to an embedis channel called "log".
// Use SUBSCRIBE LOG to get these messages.
// Logs are also printed to Serial until an empty message is received.
// Success with WiFi sends an empty message.
void LOG(const String& message) {
    static bool inSetup = true;
    if (inSetup) {
        if (!message.length()) {
            inSetup = false;
            return;
        }
        Serial.println(message);
    }
    Embedis::publish("log", message);
}
